/* COMMON */
body {
  color: #333333;
  font-size: 16px;
  font-weight: 400;/* 글자 두께 */
  line-height: 1.4;/* 행간격 설정 */
  font-family: "Nanum Gothic", sans-serif;  
  /* height: 3000px; */
  /* 스크롤바가 생김 */
}
img {
  display: block;
  /* 이미지 요소는 기본적으로 inline 요소.
     inline 요소는 가로,세로 값을 가질 수 없고, margin과 padding의 값을 가질 수 없는
     글자처럼 취급되는 요소. 글자처럼 취급되어 위아래 방향에 불규칙적인 공백이 생김.
     그래서 inline 요소를 block 요소로 바꾸어주도록 적용함.
  */
}
a {
  text-decoration: none; /* 모든 a태그에 밑줄 제거*/
}
.inner {
  width: 1100px;
  margin: 0 auto;
  position: relative;
}
.btn {
  /* 버튼의 디자인이 반복적으로 사용되므로 전역적으로 클래스의 이름을 사용하여 정의함 */
  width: 130px;
  padding: 10px;
  border: 2px solid #333;
  border-radius: 4px;
  color: #333;
  font-size: 16px;
  font-weight: 700;/* 글자 두께 */
  text-align: center;/* 글자 정렬 */
  cursor: pointer;
  box-sizing: border-box;
  /* border가 들어갈 때, 버튼 크기를 위에서 정의한 값으로 일정하게 유지도되록 함.*/
  display: block;
  transition: .4s;
}
.btn:hover {
  background-color: #333;
  color: #fff;
}
/* 일반적으로 html에서 클래스의 이름을 정의하고 html에 맞게 css를 정의하여 
   디자인을 적용하도록 한다. 그러나 반대로 css 내용을 아래와 같이 추가한 상태에서
   html에서 선택자에 맞게 클래스를 구현하여 디자인을 적용할 수도 있다. */
.btn.btn--reverse {
  /* 반전된 디자인의 버튼 */
  background-color: #333;
  color: #fff;
}
.btn.btn--reverse:hover {
  background-color: transparent;
  color: #333;
}
.btn.btn--brown {
  /* hover 하였을 때, 글자색만 변하는 다른 스타일의 버튼 */
  color: #592B18;
  border-color: #592B18;
}
.btn.btn--brown:hover {
  color: #fff;
  background-color: #592B18;
}
.btn.btn--gold {
  color: #D9AA8A;
  border-color: #D9AA8A;
}
.btn.btn--gold:hover {
  color: #fff;
  border-color: #D9AA8A;
}
.btn.btn--white {
  color: #fff;
  border-color: #fff;
}
.btn.btn--white:hover {
  color: #333;
  background-color: #fff;
}
.back-to-position {
  /* 애니메이션이 적용되기 전에 화면에 나타나지 않도록 설정 */
  opacity: 0;
  transition: 1s;
}
.back-to-position.to-right {
  /* 왼쪽에서 오른쪽으로 나타나는 애니메이션 효과 적용 */
  transform: translateX(-150px);
  /* 화면에 있는 요소를 왼쪽으로 150px만큼 이동시켜 둠.
     .show 클래스명이 붙으면 다시 돌아오게 되어서
     왼쪽에서 오른쪽으로 150px만큼 이동하는 효과를 만듬. */
}
.back-to-position.to-left {
  /* 오른쪽에서 왼쪽으로 나타나는 애니메이션 효과 적용 */
  transform: translateX(150px);
  /* 화면에 있는 요소를 오른쪽으로 150px만큼 이동시켜 둠.
     .show 클래스명이 붙으면 다시 돌아오게 되어서
     오른쪽에서 왼쪽으로 150px만큼 이동하는 효과를 만듬. */
}
.show .back-to-position {
  opacity: 1;
  transform: translateX(0);
}
.show .back-to-position.delay-0 {
  transition-delay: 0s;
}
.show .back-to-position.delay-1 {
  transition-delay: .3s;
}
.show .back-to-position.delay-2 {
  transition-delay: .6s;
}
.show .back-to-position.delay-3 {
  transition-delay: .9s;
}

/* HEADER */
header {
  background-color: #f6f5f0;
  border-bottom: 1px solid #c8c8c8;
  /* position: relative; */
  /*badges 의 position 설정을 위한 부모 요소의 디폴트 position 설정 */

  position: fixed;
  top: 0;
  /*브라우저의 뷰포트를 기준으로 위치시키는 설정
    fixed를 사용한 경우 가로 너비를 최소한의 값으로 사용하도록 설정함. */
  width: 100%; /* fixed로 변경한 경우 좌우 여백을 최대한으로 사용하도록 설정함 */
  /* 위의 설정을 하면 스크롤을 내리더라도 header가 화면의 상단에 고정되어 나타남 */

  z-index: 9;
  /* section 부분과 header 부분의 쌓임순서에 대해 section 부분이 header의 
     badges 이미지를 가림으로 header의 쌓임순서 값을 높임. 임의로 9라는 값을 주어
     이후에 다른 요소들이 추가되어 쌓임순서 크기가 다양해질 경우를 고려함 */
}
header > .inner {
  /* > : 자식선택자. 즉, 오직 header의 자식요소인 inner에 대해서만
         아래의 css 설정을 적용함. */
  /* position: relative; */
  /* logo의 position 설정에 대한 상위 요소의 position 설정 */
  /* width: 1100px; */
  height: 120px;
  /* margin: 0 auto;*/ /*0:위,아래, auto: 좌우 */
  /* inner 클래스가 메뉴의 contents 부분과 중복되므로
     위에서 전역적으로 inner 클래스에 대해 설정하고, 중복되는 부분은 제거함. 
     여기서 inner에 대한 설정은 오직 header 내에 있는 inner에 대한 설정임 */
}
header .logo {
  height: 75px;
  /* 아래는 로고 이미지를 상위 요소 내에서 수직 가운데 위치하도록 하기 위한 설정.*/
  position: absolute;
  /* 배치 기준을 상위 요소에 찾음. DOM 트리를 따라 올라가다가 position 속성이 
     static이 아닌 첫번째 상위 요소가 해당 요소의 배치 기준으로 설정됨.
     여기서 첫번째 상위요소는 .inner가 된다. */
  top: 0;
  bottom: 0;
  left: 0;
  margin: auto;
  /* 부모요소를 기준으로 수직 정가운데 위치하도록 설정. 
     top 0 지점과 bottom 0 지점을 기준으로 브라우저가 자동으로 margin값을 계산하여(auto)
     요소를 위치시킨다.
     요소의 위쪽여백, 아래쪽 여백을 계산하기 위해 요소의 높이값(height)도 설정해주어야 함.
  */
  /* .logo 하위의 img 요소에 대한 설정은 위에 있음. */
}
header .sub-menu {
  display: flex;
  /* 하위 요소인 ul 태그의 요소와 search 부분의 div 요소를 수평으로 배치 */

  position: absolute;
  top: 10px;
  right: 0;
  /* sub-menu 요소의 전체적인 위치 설정. 오른쪽 위의 위치로 설정함 */
}
header .sub-menu ul.menu {
  font-family: Arial, sans-serif; /* 글꼴 설정 */
  display: flex; /* 하위의 요소들을 수평으로 정렬함.*/
}
header .sub-menu ul.menu li {
  position: relative;
}
header .sub-menu ul.menu li::before{
  /* before : 가상 요소 선택자. li 요소 앞 부분에 무언가를 설정하겠다는 의미
     a 태그 사이의 수직바(구분선) 만들기 */
  content: "";
  width: 1px;
  height: 12px;
  background-color: #e5e5e5;

  position: absolute;
  top: 0;
  bottom: 0;
  margin: auto;
  /* 구분선의 위치 설정 */
}
header .sub-menu ul.menu li:first-child:before{
  /* first-child : 가상 요소 선택자 중에서 첫번째 요소에 대한 설정 
     화면에서 Sign In 태그 앞에 나타나는 구분선을 제거하도록 설정 */
  display: none;
}
header .sub-menu ul.menu li a {
  font-size: 12px;
  padding: 11px 16px;
  display: block;
  /* a 태그는 inline 요소이고, inline 요소는 margin, padding 값을
     제대로 사용할 수 없다. a가 inline 요소일 때, 글자 크기를 설정하면,
     글자 부분 이외의 부분을 클릭할 때, 원하는 결과대로 페이지 이동이 잘 안될 수 있다.
     여기서 padding을 설정하고, padding이 적용가능하도록 하기 위해,
     해당 요소를 block으로 설정한다. */
  color: #656565;
}
header .sub-menu ul.menu li a:hover{
  /* hover : a 태그에 마우스를 올렸을 때에 대한 처리 */
  color: #000;
}
header .sub-menu .search {
  height: 34px;
  position: relative;
  /* 하위 요소 .material-icons에 position을 적용하기 위한 부모요소에서의
     position 설정. */
}
header .sub-menu .search input {
  width: 36px;
  height: 34px;
  padding: 4px 10px; /* 앞의 4px는 위아래, 뒤의 10px는 좌우의 padding 설정 */
  border: 1px solid #ccc;
  box-sizing: border-box;
  /* 요소의 크기 기준을 위에서 설정한 가로 36px, 세로 34px를 유지하면서
     내부 여백과 테두리선(border)이 추가되도록 설정함.
     
     디폴트 값은 'content'. 이 설정의 상태에서 border나 padding이 추가되면
     요소의 너비ㅏ 높이에 추가가 되어 해당 box의 크기는 그만큼 더 커지게 된다.
     'border-box'에 border나 padding을 추가하면 해당 box의 크기는 그만큼
     더 커지지 않고 사용자가 지정한 너비나 높이만큼 길이에 맞추게 된다. */
  border-radius: 5px;/* 현재의 input 요소의 모서리 라운드 설정 */
  outline: none;
  /* input 요소의 가장자리에 나타나는 파란색 테두리선.
     제어하기가 쉽지 않기 때문에 outline을 사용하지 않도록 설정. */
  background-color: #fff;
  color: #777;/* 글자색 설정*/
  font-size: 12px;
  transition: width .4s;
  /* 아래의 focus 설정을 통해 요소가 변할 때, 시간을 설정하여
     자연스럽게 변하도록 함.*/
}
header .sub-menu .search input:focus {
  /* focus : 해당하는 input 요소에 초점이 맞추어졌을 때에 대한 설정 */
  width: 190px;
  border-color: #669900;
}
header .sub-menu .search .material-icons {
  position: absolute;
  height: 24px; /* 해당 요소의 여백 설정에 사용되는 height 설정 */
  top: 0;
  bottom: 0;
  right: 5px;
  margin: auto;
  /* search icon을 클릭하였을 떄는 focus의 효과가 나타나지 않으며,
     이에 대한 설정은 css에서 제어할 수 있는 영역을 벗어나기 때문에
     자바스크립트에서 설정해주어야 한다. */
  transition: .4s;
  /* 돋보기 아이콘이 자연스럽게 사라지도록 하기 위한 시간 설정 */
}
header .sub-menu .search.focused .material-icons {
  /* search 부분이 focus 되었을 때에 대한 설정 */
  opacity: 0; /* focus 되었을 때, 아이콘을 숨김 */
}
header .main-menu {
  display: flex;/* 하위의 li 요소를 수평으로 배치 */
  position: absolute;
  bottom: 0;
  right: 0;
  /* 메뉴 전체를 부모요소를 기준으로 정할 수 있도록 설정
     부모요소에서 오른쪽 아래에 위치하도록 함 */
  z-index: 1;
  /* 마우스가 올려져서 목록이 나타날 때, 요소가 다른 요소들보다 위에 나타나도록 설정 */
}
header .main-menu .item {

}
header .main-menu .item .item__name {
  padding: 10px 20px 34px 20px;
  font-family: Arial, sans-serif;
  font-size: 13px;
}
header .main-menu .item:hover .item__name {
  /* hover : 글자 부분만이 아닌 item 전체에 대해 
    마우스가 올라갔을 때 적용되도록 함*/
  background-color: #2c2a29;
  color: #669900;/* 글자색 변경 */
  border-radius: 6px 6px 0 0;/* 순서 : 좌상 우상 우하 좌하 */
}
header .main-menu .item .item__contents {
  width: 100%;
  position: fixed;/* viewport를 기준으로 배치한다 */
  left: 0;
  /* top이나 bottom 속성을 사용하지 않아 수직 위치 값이 없다면
     요소의 원래 위치를 그대로 사용한다.
     만약 position: absolute;를 사용했다면, (위치상) 부모 요소를 기준으로 하므로
     화면의 뷰포트 좌우 끝까지 늘어날 수 없게 된다. */
  display: none;
}
header .main-menu .item:hover .item__contents {
  display: block;
}
header .main-menu .item .item__contents .contents__menu {
  background-color: #2c2a29;
}
header .main-menu .item .item__contents .contents__menu > ul {
  /* > : 자식선택자 사용. contents__menu 하위에 ul 태그가 2번 나타나기
      떄문에 바로 아래의 자식요소에 대해서만 css를 적용하도록 설정함. */
  display: flex;
  padding: 20px 0;
}
header .main-menu .item .item__contents .contents__menu > ul > li {
  width: 220px;/*header의 수평방향으로 나타나는 리스트 너비 설정 */
}
header .main-menu .item .item__contents .contents__menu > ul > li h4 {
  padding: 3px 0 12px 0;/* 위,우,아래,좌 순서로 설정 */
  font-size: 14px;
  color: #fff;
}
header .main-menu .item .item__contents .contents__menu > ul > li ul li {
  padding: 5px 0;
  font-size: 12px;
  color: #999;
  cursor: pointer;
}
header .main-menu .item .item__contents .contents__menu > ul > li ul li:hover {
  color: #669900;/* 리스트 위에 마우스가 올려졌을 때 글자색 변경 */
}
header .main-menu .item .item__contents .contents__texture {
  padding: 20px 0;
  font-size: 12px; /* h4, p 2개의 태그에 대해 동일한 글자 크기 설정을 함 */
  background-image: url("../images/main_menu_pattern.jpg");
  /* 배경을 이미지로 설정함. 이미지가 반복되는 패턴으로 나옴 */
}
header .main-menu .item .item__contents .contents__texture h4 {
  color: #999;
  font-weight: 700;
}
header .main-menu .item .item__contents .contents__texture p {
  color: #669900;
  margin: 4px 0 14px;
}
header .badges {
  position: absolute;
  top: 132px;
  right: 12px;
}
header .badges .badge {
  border-radius: 10px;
  overflow: hidden;
  /* 이미지에 라운드를 줄 때, 내부의 이미지가 그 경계를 넘어서지 않도록 설정*/
  margin-bottom: 12px;
  box-shadow: 4px 4px 10px rgba(0,0,0,.15);/*그림자 효과*/
  cursor: pointer;/*커서가 요소 위에 있을 때, 모양이 변함 */
}

/* VISUAL */
.visual {
  margin-top: 120px;/* header의 높이값을 고려함 */
  background-image: url("../images/visual_bg.jpg");
  background-position: center;/* 이미지를 하나만 넣음 */
}
.visual .inner {
  height: 646px;
}
.visual .title {
  /* visual과 title 사이의 inner 선택자를 생략해주는 것도 좋다 */
  position: absolute;
  top: 88px;
  left: -10px;
}
.visual .title .btn {
  /* 버튼에 대한 디자인 및 hover는 위의 디폴트로 설정한 값을 적용하도록 하며
     여기서는 버튼의 위치만 조절한다. */
  position: absolute;
  /* absolute 설정은 부모요소를 기준으로 배치한다는 의미. 
     여기서 .btn의 부모요소는 .title이며, 부모요소에 position이 설정되어 있음.
     배치하려는 특정요소가 다른 요소에 묶여져있다고 여겨질 때, 여기서와 같이
     함께 묶어서 배치하는 방식을 적용하는 것이 좋다. */
  top: 259px;
  left: 173px;
}
.visual .cup1.image {
  position: absolute;
  bottom: 0;
  right: -47px;
}
.visual .cup1.text {
  position: absolute;
  top: 38px;
  right: 171px;
}
.visual .cup2.image {
  position: absolute;
  bottom: 0;
  right: 162px;
}
.visual .cup2.text {
  position: absolute;
  top: 321px;
  right: 416px;
}
.visual .spoon {
  position: absolute;
  bottom: 0;
  left: 275px;
}
.visual .fade-in {
  opacity: 0;
  /* 처음의 투명도를 0으로 설정하여 화면에 나타나지 않도록 함.
     화면에 서서히 나타나는 것은 js에서 구현함.
  */
}

/* NOTICE */
.notice {

}
.notice .notice-line {
  position: relative;
}
.notice .notice-line .bg-left {
  position: absolute;
  top: 0;
  left: 0;
  width: 50%;
  height: 100%;
  background-color: #333;
}
.notice .notice-line .bg-right {
  position: absolute;
  top: 0;
  right: 0;
  width: 50%;
  height: 100%;
  background-color: #f6f5ef;
}
.notice .notice-line .inner {
  height: 62px;
  /* 위에서 inner의 부모요소인 .notice-line의 position 설정이 relative이므로
     값이 줄어들면서 자식요소의 최소 너비, 높이 설정값을 적용하여 화면에 나타내게 된다.
     여기서 inner 요소의 높이값을 크게 적용하면 inner의 높이값이 적용되어 화면에
     나타나게 된다.
     위의 .notice-line의 자식요소인 .bg-left, .bg-right 요소의 높이를 조절하고자 할 때,
     각각의 요소의 높이를 지정해주어야 한다. 이 떄 자식의 요소가 이 뿐만 아니라 더 많아지게 되는 경우
     각각의 자식요소에 높이를 설정해주어야 하는 불편함이 있다.
     이를 간단하게 처리하기 위해 동일한 위치에 .inner와 같은 div를 추가하여 높이를 설정하고,
     다른 자식요소에서는 높이값을 100%로 설정한 후, 부모의 position 값으로 relative로 설정하여
     .inner 클래스에서 설정한 높이값이 모든 자식요소에 대해 적용될 수 있도록 더 간편하게 처리할 수 있다. */
  /* border: 2px solid red; */
  display: flex; /* 자식요소를 수평으로 배치 */
}
.notice .notice-line .inner__left {
  width: 60%; /* .inner__left 요소의 텍스트가 더 길게 나타나므로 width의 비율을 다르게 준다. */
  height: 100%;
  background-color: #333;
  display: flex;
  align-items: center;/* 수직방향에서 가운데 정렬 */
}
.notice .notice-line .inner__left h2 {
  color: #fff;
  font-size: 17px;
  font-weight: 700;
  margin-right: 20px;
}
.notice .notice-line .inner__left .swiper-container {
  /* 높이는 값을 부여하지 않아도 부모요소에서 display: flex; 설정으로 인해
     최대로 사용한다. */
  height: 62px;
  /* 높이를 적용하지 않은 경우에 이전에 수직방향 최대로 나타나다가, 부모요소인
     .inner__left에서 align-items 설정으로 인해, 이 요소의 높이가 사라지게 된다.
     여기서 높이를 다시 설정하여야 한다. */
  /* background-color: orange; */
  flex-grow: 1;
  /* 너비가 남아있는 경우, 남은 여백(너비)를 최대로 사용하도록 하거나,
     또는 비율 설정에 따라 여백을 나타내도록 한다.*/
}
.notice .notice-line .inner__left .swiper-slide {
  height: 62px;
  display: flex;
  align-items: center;
}
.notice .notice-line .inner__left .swiper-slide a {
  color: #fff;
}
.notice .notice-line .inner__left .notice-line__more {
  width: 62px;
  height: 62px;
  display: flex;/* 아이콘을 가운데정렬시키기 위해 필요함. */
  justify-content: center;/* 수평방향에서 가운데 정렬*/
  align-items: center;/* 수직방향에서 가운데 정렬*/
}
.notice .notice-line .inner__left .notice-line__more .material-icons {
  color: #fff;
  font-size: 30px;
}
.notice .notice-line .inner__right {
  width: 40%;
  height: 100%;
  display: flex;
  justify-content: flex-end;/* 오른쪽 정렬 */
  align-items: center;
}
.notice .notice-line .inner__right h2 {
  font-size: 17px;
  font-weight: 700;
}
.notice .notice-line .inner__right .toggle-promotion {
  width: 62px;
  height: 62px;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
}
.notice .notice-line .inner__right .toggle-promotion .material-icons {
  font-size: 30px;
}
.notice .promotion {
  height: 693px;
  background-color: #f6f5ef;
  position: relative;

  transition: height .4s;
  /* 아래의 .promotion.hide가 적용될 떄 변하는 시간 설정 */
}
.notice .promotion.hide {
  height: 0;
  /* toggle-promotion 요소를 클릭하므로 js에서의 제어에 따라
     class='promotion'에서 class='promotion hide'로
     클래스 이름이 변경된다. 이 때, 높이 값을 0으로 설정하여
     .promotion 객체를 화면에서 감추도록 표현한다. */
}

.notice .promotion .swiper-container {
  width: calc(819px * 3 + 20px);
  /* 요소와 요소 사이의 여백을 더하여 전체 너비를 구할 떄, 
     자동적으로 계산하는 함수를 사용하여 실수하지 않도록 방지함 */
  height: 553px;
  /* background-color: orange;
  text-align: center;
  font-size: 200px; */
  /* 여기서 center로 설정을 하였을 때, 이 요소의 전체가 화면에 들어오는 경우에는
     가운데 정렬이 된 것처럼 나타난다. 그러나 웹페이지가 전체적으로 확대된 경우에는
     가운데에 나타나지 않는다.*/

  position: absolute;
  top: 40px;
  left: 50%;
  margin-left: calc((819px * 3 + 20px)/-2);
  /* .swiper-container를 페이지 확대, 축소와 상관없이 항상 가운데 정렬처럼
     나타나도록 하기 위해 먼저 position을 설정한다.
     left: 50%를 설정하면, 내부의 요소들이 전체적으로 확대,축소된 상태의 화면에서
     50% 밀려진 위치에 나타나게 된다. 이후 전체 너비값에서 다시 절반을 뺀 값으로
     margin 값을 설정하여 확대,축소에 상관없이 요소를 항상 가운데 나타나도록 할 수 있다.
  */
}
.notice .promotion .swiper-slide {
  /* 모든 슬라이드 이미지를 투명하게 나타냄 */
  opacity: .5;
  transition: opacity 1s;
  /* opacity 속성이 변할 때, 1초의 시간 동안 자연스럽게 바뀌도록 설정 */
  position: relative;
}
.notice .promotion .swiper-slide-active {
  /* 슬라이드 중 활성화된 이미지의 투명도를 다시 선명하게 조정함 */
  opacity: 1;
}
.notice .promotion .swiper-slide .btn {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  margin: auto;
  /* 부모요소인 .swiper-slide를 기준으로 버튼을 배치함 */
}
.notice .promotion .swiper-pagination {
  bottom: 40px;
  left: 0;
  right: 0;
  /* .swiper-pagination에 대한 css 설정은 기본적으로 swiper 라이브러리에 정의된대로
     css를 적용하고, 여기서 추가적으로 설정한 bottom, left, right 설정이
     라이브러리의 설정에 더하여져서 적용된다.
     라이브러리의 나머지 설정은 아래와 같다. 위에서 가운데 정렬을 설정해주지 않아도
     라이브러리의 선언이 적용되어 가운데 정렬이 된다.
     .swiper-pagination {
        position: absolute;
        text-align: center;
        transition: .3s opacity;
        transform: translate3d(0,0,0);
        z-index: 10;
      }
      
      아래는 swiper 라이브러리에서 각각의 번호를 표현하는 bullet 모양의 css이다.
      .swiper-pagination-bullet {
        width: 8px;
        height: 8px;
        display: inline-block;
        border-radius: 50%;
        background: #000;
        opacity: .2;
      }
  */
}

.notice .promotion .swiper-pagination .swiper-pagination-bullet {
  /* .swiper-pagination-bullet의 css 디자인을 커스터마이징 함 */
  background-image: url("../images/promotion_slide_pager.png");
  width: 12px;
  height: 12px;
  margin-right: 6px;
  outline: none;
}
.notice .promotion .swiper-pagination .swiper-pagination-bullet:last-child {
  /* 위에서 설정한 margin-right는 bullet 요소의 사이사이에 여백을 만들기 위한 설정이며,
     가장 오른쪽의 요소에 대해서는 margin이 필요하지 않기 때문에 last-child를 사용하여
     마지막의 요소에 margin을 적용하지 않도록 함*/
  margin-right: 0;
}
.notice .promotion .swiper-pagination .swiper-pagination-bullet-active {
  background-image: url("../images/promotion_slide_pager_on.png");
  /* 활성화된 bullet 요소에 대한 이미지 적용.
     가져온 이미지와 기존에 라이브러리에 정의된 css는 거의 비슷함. */
}
.notice .promotion .swiper-prev,
.notice .promotion .swiper-next {
  /* 선택자의 css 디자인이 동일한 경우 디자인을 중복적으로 선언하지 않고
     위와 같이 선언하여 동일한 css를 간견할게 적용할 수 있다.
     선택자가 2개라는 것을 직관적으로 보기 위해, 위와 같이 두줄로 나누어
     선언해두는 것이 좋다.*/
  width: 42px;
  height: 42px;
  border: 2px solid #333;
  border-radius: 50%;
  position: absolute;
  top: 300px;
  z-index: 1;
  cursor: pointer;
  outline: none;
  display: flex;
  justify-content: center;
  align-items: center;
  /* 화살표 아이콘을 수직,수평 방향에서 가운데 정렬 */
  transition: .4s;
}
.notice .promotion .swiper-prev {
  left: 50%;
  margin-left: -480px;
}
.notice .promotion .swiper-next {
  right: 50%;
  margin-right: -480px;
}
.notice .promotion .swiper-prev:hover,
.notice .promotion .swiper-next:hover {
  background-color: #333;
  color: #fff;
}

/* REWARDS */
.rewards {
  position: relative;
}
.rewards .bg-left  {
  width: 50%;
  height: 100%;
  background-color: #272727;
  position: absolute;
  top: 0;
  left: 0;
}
.rewards .bg-right {
  width: 50%;
  height: 100%;
  background-color: #d5c798;
  position: absolute;
  top: 0;
  right: 0;
}
.rewards .inner {
  background-image: url("../images/rewards.jpg");
  height: 241px;
}
.rewards .btn-group{
  /* .btn-group의 부모 요소는 .inner 이다. 위에서 .inner 요소에
     position값을 주지는 않았지만, 가장 위 COMMON 부분에 전역적으로 
     .inner에 대한 position 값을 relative로 선언하였기 떄문에
     position 설정이 적용된다. */
  position: absolute;
  bottom: 24px;
  right: 0;
  width: 250px;
  display: flex;
  flex-wrap: wrap;
  /* 가로 정렬에서 요소가 너비의 범위를 넘으면 줄바꿈을 허용하는 설정 */
}
.rewards .btn-group .btn.sign-up {
  margin-right: 10px;
}
.rewards .btn-group .btn.sign-in {
  width: 110px;
}
.rewards .btn-group .btn.gift {
  margin-top: 10px;
  flex-grow: 1;
  /* 너비의 증가 비율을 설정하여 최대가 되도록 함.*/
}

/* YOUTUBE VIDEO */
.youtube {
  position: relative;
  height: 700px;
  background-color: #333;

  overflow: hidden;
  /* 하위요소(.youtube__area)들이 부모요소의 범위를 벗어날 때,
     벗어난 부분을 잘라냄. */
}
.youtube .youtube__area {
  width: 1920px;
  background-color: orange;
  position: absolute;
  left: 50%;
  margin-left: calc(1920px / -2);
  /* 화면의 왼쪽에서 50%지점의 위치에 요소를 배치하고,
     margin-left 값을 주어서 결과적으로 정가운데 위치에
     요소를 배치함 */
  top: 50%;
  margin-top: calc(1920px * 9 / 16 / -2);
  /* 이 요소를 부모요소 내에서 수직방향으로 정가운데 위치에
     위치시킴 */
}
.youtube .youtube__area::before {
  content: "";
  display: block;
  /* inline요소를 block 요소로 변경하여
     설정하는 너비, 높이 값이 잘 적용되도록 함 */
  width: 100%;
  height: 0;
  padding-top: 56.25%;
  /* 부모너비와 자식너비의 값을 넣고
     padding 값을 이용하고 부모의 너비를 조정하여
     요소의 가로,세로 너비를 비율을 설정하여 조정할 수 있다.
     16:9 비율의 요소를 만들어냄 */
}
.youtube .youtube__cover {
  background-image: url("../images/video_cover_pattern.png");
  background-color: rgba(0,0,0,.3);
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  /* 30%의 불투명도를 가지는 배경을 출력 */
}
#player { /* id 선택자 */
  width: 100%;
  height: 100%;
  position: absolute; /* player의 부모요소는 .youtube__area */
  top: 0;
  left: 0;
}
.youtube .inner {
  height: 700px;
  /* background-color: royalblue; */
}
.youtube .floating1 {
  position: absolute;
  top: 50px;
  left: 0;
}
.youtube .floating2 {
  position: absolute;
  top: 350px;
  left: 150px;
}
/* .youtube .floating3 {
  position: absolute;
  bottom: -200px;
  right: 0;
} */
/* floating3 에 대한 이미지를 youtube section에서 제거하고
   season section으로 넘겨줌. */

/* SEASON PRODUCT */
.season-product {
  background-image: url("../images/season_product_bg.jpg");
}
.season-product .inner {
  height: 400px;
}
.season-product .floating3 {
  position: absolute;
  top: -200px;
  right: 0;
}
.season-product .text-group {
  position: absolute;
  /* .text-group의 부모요소는 inner이며 inner는 전역적으로 position 값을 이미 설정함. */
  top: 110px;
  right: 100px;
}
.season-product .text-group .title {
  margin-bottom: 10px;
}
.season-product .text-group .description {
  margin-bottom: 15px;
}
.season-product .text-group .more {
  
}

/* RESERVE COFFEE */
.reserve-coffee {
  background-image: url("../images/reserve_bg.jpg");
}
.reserve-coffee .inner {
  height: 400px;
}
.reserve-coffee .reserve-logo {
  position: absolute;
  top: 110px;
  left: 0;
}
.reserve-coffee .text-group {
  position: absolute;
  top: 124px;
  left: 208px;
}
.reserve-coffee .product {
  position: absolute;
  top: 0;
  right: 0;
}

/* PICK YOUR FAVORITE */
.pick-your-favorite {
  background-image: url("../images/favorite_bg.jpg");
  background-repeat: no-repeat;
  background-position: center;
  background-attachment: fixed;
  /* 기본적으로는 화면이 스크롤 될 때, 요소(이미지)도 함께 스크롤이 됨.
     attachment를 fixed로 설정하면, 스크롤 할 떄, 요소가 더이상 스크롤 되지 않고,
     이미지가 화면의 뷰포트 부분에 고정이 된다. */
  background-size: cover;
  /* 배경이미지를 요소의 더 넓은 너비에 맞추어서 출력함. */
}
.pick-your-favorite .inner {
  padding: 110px 0;
}
.pick-your-favorite .text-group {
  /* background-color: orange; */
  margin-left: 100px;
  width: 362px;
  display: flex;
  flex-wrap: wrap;
  /* 가로 정렬에서 요소가 너비의 범위를 넘으면 줄바꿈을 허용하는 설정 */
  justify-content: flex-end;
}
.pick-your-favorite .text-group .title {
  margin-bottom: 40px; 
}
.pick-your-favorite .text-group .description {
  margin-bottom: 40px;
}

/* RESERVE STORE */
.reserve-store {
  background-image: url("../images/reserve_store_bg.jpg");
  background-repeat: no-repeat;
  background-position: center;
  background-attachment: fixed;
  background-size: cover;
}
.reserve-store .inner {
  height: 600px;
  /* 상위요소인 .reserve-store에서 배경이미지의 높이를 설정하지 않았으므로 
     하위요소 .inner 클래스에서 선언한 높이만큼 배경이미지 높이가 설정됨 */
  display: flex;
  justify-content: center;
  align-items: center;
  /* inner 요소(medal 이미지)를 가운데 정렬 */
}
.reserve-store .medal {
  width: 334px;
  height: 334px;
  perspective: 600px;
  /* 원근법의 거리를 추가하여, 회전되는 효과를 살려줌. */
}
.reserve-store .medal .front,
.reserve-store .medal .back {
  width: 344px;
  height: 344px;
  backface-visibility: hidden;
  /* 각 요소가 뒤집어졌을 때, 요소들이 화면에서 보이지 않게 하는 설정 */
  transition: 1s;
  /* hover할 때의 회전효과 시간을 1초로 설정 */
  position: absolute;
}
.reserve-store .medal .front {
  /* position: absolute; */
  /* position을 부모요소에 맞추어 줌으로써, 2개의 이미지를 겹쳐줌 */
  transform: rotateY(0deg);
  /* 처음의 각도를 0도에서 시작하도록 설정함. 웹에 따라 기본 설정이
     달라질 수도 있기 때문. */
}
.reserve-store .medal:hover .front {
  transform: rotateY(180deg);
  /* medal 부분에 hover하였을 때, 이미지를 180도 회전.
     backface-visibility 설정으로 인해 화면에 나타나지 않음 */
}
.reserve-store .medal .back {
  transform: rotateY(-180deg);
  /* 'back' 이미지를 180도 뒤집은 설정 
     뒤집은 설정과 backface-visibility 설정으로 인해, 처음에는 'back'
     이미지 요소가 화면에 나타나지 않음. */
}
.reserve-store .medal:hover .back {
  transform: rotateY(0deg);
  /* medal 부분에 hover하였을 때, 이미지를 다시 0도 상태로 돌림.
     이 때, backface-visibility 효과가 적용되지 않아서 다시 화면에 나타남. */
}
.reserve-store .medal .back .btn{
  position: absolute;
  /* 부모요소를 기준으로 배치 */
  top: 240px;
  left: 0;
  right: 0;
  margin: auto;
  /* .btn에 대한 공통클래스 설정에서 너비 값을 넣어두었기 때문에, 여기서
     너비를 설정하지 않아도 됨. */
}

/* FIND STORE */
.find-store {
  background-image: url("../images/find_store_bg.jpg");
}
.find-store .inner {
  height: 400px;
  /* 배경이미지의 높이 설정 */
}
.find-store .texture1 {
  position: absolute;
  top: 0;
  left: 400px;
  /* 부모요소는 inner이미 inner에는 이미 position이 설정되어 있음. */
}
.find-store .texture2 {
  position: absolute;
  bottom: 0;
  right: 0;
  /* texture2의 이미지 위치 */
}
.find-store .picture {
  border-radius: 50%;
  /* .picture 이미지를 원 모양으로 설정 */
  box-shadow: 2px 2px 8px rgba(0,0,0,.5);
  /* 그림자 효과 */
  position: absolute;
}
.find-store .picture1 {
  /* position: absolute; */
  /* .picture1과 .picture2의 position 설정이 동일하므로 .picture 클래스 설정에서
     position을 설정함. */
  top: -60px;
  left: 0;
  /* picuture1의 이미지 위치 */
}
.find-store .picture2 {
  /* position: absolute; */
  top: 150px;
  left: 250px;
  /* picuture2의 이미지 위치 */
}
.find-store .text-group {
  position: absolute;
  top: 120px;
  left: 550px;
}
.find-store .text-group .title {
  margin-bottom: 20px;
}
.find-store .text-group .description {
  margin-bottom: 20px;
}


/* AWARDS */
.awards {
  background-color: #272727;
}
.awards .inner{
  padding: 40px 0;
}
.awards .swiper-container {
  width: 100%;
  height: 40px;
}
.awards .swiper-prev,
.awards .swiper-next {
  width: 42px;
  height: 42px;
  border: 2px solid #fff;
  border-radius: 50%;
  outline: none;
  color: #fff;
  opacity: .3;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;

  position: absolute;
  top: 0;
  bottom: 0;
  margin: auto;
  /* 부모기준 수직방향으로 가운데 배치 */
}
.awards .swiper-prev {
  left: -100px;
}
.awards .swiper-next {
  right: -100px;
}
.awards .swiper-prev:hover,
.awards .swiper-next:hover {
  background-color: #fff;
  color: #333;
}

/* FOOTER */
footer {
  background-color: #272727;
  border-top: 1px solid #333;
}
footer .inner {
  padding: 40px 0 60px 0;
}
footer .menu {
  display: flex; /* 수평으로 나열하도록 함 */
  justify-content: center;
}
footer .menu li {
  position: relative;
}
footer .menu li::before {
  content: "";
  width: 3px;
  height: 3px;
  background-color: #555;
  position: absolute;
  top: 0;
  bottom: 0;
  right: -1px;
  margin: auto;
}
footer .menu li:last-child::before {
  display: none;
}
footer .menu li a {
  color: #ccc;
  font-size: 12px;
  font-weight: 700;
  padding: 15px;

  display: block;
  /* 사용자가 a 요소를 클릭할 수 있는 범위를 늘려줌. */
}
footer .menu li a.green {
  color: #669900;
}
footer .btn-group {
  margin-top: 20px;
  display: flex;
  justify-content: center;
}
footer .btn-group .btn {
  font-size: 12px;
  margin-right: 10px;
}
footer .btn-group .btn .btn:last-child {
  margin-right: 0;
}
footer .info {
  margin-top: 30px;
  text-align: center;
}
footer .info span {
  margin-right: 20px;
  color: #999;
  font-size: 12px;
}
footer .info span:last-child {
  margin-right: 0;
}
footer .copyright {
  color: #999;
  font-size: 12px;
  text-align: center;
  margin-top: 12px;
}
footer .logo {
  margin: 30px auto 0;
  /* img 요소가 display: block; + margin: 0 auto; 인 경우,
     width 속성이 없이도 가운데 정렬이 가능하다.
     가장 위의 common 부분에서 img 요소에 display: block;을 지정하였다. */
}

#to-top {
  width: 42px;
  height: 42px;
  background-color: #333;
  color: #fff;
  border: 2px solid #fff;
  border-radius: 10px;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
  position: fixed; /* 뷰포트를 기준으로 배치함. */
  bottom: 30px;
  right: 30px;
  z-index: 9s; /* 요소가 항상 위에 나타나도록 함. */
}
/*  */